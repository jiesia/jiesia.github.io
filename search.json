[{"title":"冒泡排序","url":"/2022/06/05/algorithm/sort/bubbleSort/","content":"\n时间复杂度：\n\n算法步骤\n遍历数组，遍历过程中依次比较相邻两个元素，如果这两个数字逆序就交换它们的位置。\n不断在越来越少的元素上进行第 1 步，每次都可以将当前遍历区域上最大的元素放在区域最后。\n\n动画演示\n代码实现function bubbleSort(nums: number[]) {  const { length } = nums;    for (let i = length; i &gt; 0; i--) {    for (let j = 0; j &lt; i; j++) {      // 相邻元素对比      if (arr[j] &gt; arr[j + 1]) {        // 交换元素        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];      }    }  }}\n","categories":["算法","排序"]},{"title":"归并排序","url":"/2022/06/05/algorithm/sort/mergeSort/","content":"\n时间复杂度：\n分治算法\n\n归并排序是建立在归并操作上的一种有效的排序算法。\n归并操作归并操作旨在将两个有序数组合并为一个有序数组。代码表示如下：\nfunction merge(nums1: number[], nums2: number[]) {  const result: number[] = [];  const { length: length1 } = nums1;  const { length: length2 } = nums2;  // 下标，分别控制两个数组当前被归并的元素下标  let i = 0, j = 0;  while (true) {    // 如果其中一个数组的元素已经归并完了，就直接拼接上另一个数组的剩余元素    if (i &gt;= length1) {      result.push(...nums2.slice(j));      break;    }    if (j &gt;= length2) {      result.push(...nums1.slice(i));      break;    }    // 获取较小的值    if (nums1[i] &lt;= nums2[j]) {      result.push(nums1[i]);      i++;    } else {      result.push(nums2[j]);      j++;    }  }  return result;}\n\n算法步骤\n将原数组分成两份，分别对分开的数组进行递归操作。\n递归出口：分开的数组长度 &lt;= 1 时返回当前数组。\n对分开的两个数组进行归并操作。\n\n动图演示\n代码实现function mergeSort(nums: number[]): number[] {  // 递归出口  if (nums.length &lt;= 1) return nums;  // 将原数组分成两份  const middle = nums.length &gt;&gt; 1;  // 对分开的数组进行递归操作  const left = mergeSort(nums.slice(0, middle));  const right = mergeSort(nums.slice(middle));  // 归并分开的两个数组  return merge(left, right);}\n"}]